<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body><style>
    :root {
    --primary-color: #d4af37;
    --secondary-color: #1a1a1a;
    --text-color: #ffffff;
    --input-bg: rgba(255, 255, 255, 0.1);
    --input-border: #d4af37;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Roboto', sans-serif;
    color: var(--text-color);
    background-color: var(--secondary-color);
    line-height: 1.6;
}

.casino-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('https://images.unsplash.com/photo-1596838132731-3301c3fd4317');
    background-size: cover;
    background-position: center;
    filter: brightness(0.3);
    z-index: -1;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
}

header {
    text-align: center;
    margin-bottom: 2rem;
}

h1 {
    font-family: 'Playfair Display', serif;
    font-size: 3rem;
    color: var(--primary-color);
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

form {
    background: rgba(26, 26, 26, 0.8);
    padding: 2rem;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
}

.form-group {
    margin-bottom: 1.5rem;
}

label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: bold;
    color: var(--primary-color);
}

input[type="text"],
input[type="number"],
select,
textarea {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--input-border);
    border-radius: 5px;
    background-color: var(--input-bg);
    color: var(--text-color);
    font-size: 1rem;
    transition: all 0.3s ease;
}

input[type="text"]:focus,
input[type="number"]:focus,
select:focus,
textarea:focus {
    outline: none;
    box-shadow: 0 0 0 2px var(--primary-color);
}

select {
    height: 150px;
}

.radio-group {
    display: flex;
    justify-content: space-between;
    background-color: var(--input-bg);
    border-radius: 5px;
    overflow: hidden;
}

.radio-group input[type="radio"] {
    display: none;
}

.radio-group label {
    flex: 1;
    padding: 0.75rem;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
}

.radio-group input[type="radio"]:checked + label {
    background-color: var(--primary-color);
    color: var(--secondary-color);
}

textarea {
    resize: vertical;
    min-height: 100px;
}

.submit-btn {
    display: block;
    width: 100%;
    padding: 1rem;
    background-color: var(--primary-color);
    color: var(--secondary-color);
    border: none;
    border-radius: 5px;
    font-size: 1.1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

.submit-btn:hover {
    background-color: #b8960c;
}

@media (max-width: 768px) {
    .container {
        padding: 1rem;
    }

    h1 {
        font-size: 2rem;
    }

    form {
        padding: 1rem;
    }
}
#id_chests {
    display: none;
}
        /* Optional: Add a transition effect for smooth open/close */
    .id_chests.open {
        display: block;
        animation: fadeIn 0.3s ease-in-out;
    }
</style>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        const toggleButton = document.getElementById("toggle-chests");
        const chestsContainer = document.getElementById("id_chests");

        toggleButton.addEventListener("click", function () {
            // Check the current visibility of the container
            if (chestsContainer.style.display === "none" || !chestsContainer.style.display) {
                chestsContainer.style.display = "block";
                toggleButton.textContent = "Close Chests";
            } else {
                chestsContainer.style.display = "none";
                toggleButton.textContent = "Select Chests";
            }
        });
    });
</script>

<script>
document.addEventListener("DOMContentLoaded", function () {
    const gameData = {{ games_json|safe }}; // Game data as JSON
    const chestsSelect = document.getElementById("id_chests");
    const gameValuesField = document.getElementById("id_game_values");
    const totalValueField = document.getElementById("id_total_value");
    const quantitiesContainer = document.createElement("div"); // Container for quantity inputs
    quantitiesContainer.id = "quantities-container";
    chestsSelect.parentNode.appendChild(quantitiesContainer);

    const checkboxes = document.querySelectorAll(".form-check-input"); // Custom checkboxes

    // Function to update quantities and total value
    function updateGameValues() {
        let selectedGames = Array.from(chestsSelect.selectedOptions).map(option => parseInt(option.value));
        let gameValues = [];
        let totalValue = 0;

        selectedGames.forEach(gameId => {
            let game = gameData.find(g => g.id === gameId);
            if (game) {
                let quantityInput = document.getElementById(`quantity-${gameId}`);
                let quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                let gameCost = game.cost || 0;
                let totalGameCost = quantity * gameCost;
                gameValues.push(`${game.name}: ${quantity} x ${gameCost} = ${totalGameCost}`);
                totalValue += totalGameCost;
            }
        });

        gameValuesField.value = gameValues.join("\n");
        totalValueField.value = totalValue;
    }

    // Function to add a quantity input
    function addQuantityInput(gameId, gameName) {
        if (!document.getElementById(`quantity-container-${gameId}`)) {
            let quantityDiv = document.createElement("div");
            quantityDiv.id = `quantity-container-${gameId}`;
            quantityDiv.innerHTML = `
                <label for="quantity-${gameId}">${gameName} Quantity:</label>
                <input type="number" id="quantity-${gameId}" name="quantity-${gameId}" value="1" min="1" class="form-control">
            `;
            quantitiesContainer.appendChild(quantityDiv);

            // Listen for changes to update game values
            document.getElementById(`quantity-${gameId}`).addEventListener("input", updateGameValues);
        }
    }

    // Function to remove a quantity input
    function removeQuantityInput(gameId) {
        let quantityDiv = document.getElementById(`quantity-container-${gameId}`);
        if (quantityDiv) {
            quantityDiv.remove();
        }
    }

    // Handle changes to the chests field
    function handleSelectionChange() {
        let selectedGameIds = Array.from(chestsSelect.selectedOptions).map(option => parseInt(option.value));
        let allGameIds = gameData.map(game => game.id);

        allGameIds.forEach(gameId => {
            let game = gameData.find(g => g.id === gameId);
            if (selectedGameIds.includes(gameId)) {
                addQuantityInput(gameId, game.name);
            } else {
                removeQuantityInput(gameId);
            }
        });

        updateGameValues();
    }

    chestsSelect.addEventListener("change", handleSelectionChange);

    // Sync checkboxes with chestsSelect
    checkboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", function () {
            // Update the chestsSelect options
            const selectedValues = Array.from(checkboxes)
                .filter((cb) => cb.checked)
                .map((cb) => parseInt(cb.value));

            Array.from(chestsSelect.options).forEach((option) => {
                option.selected = selectedValues.includes(parseInt(option.value));
            });

            // Trigger the same logic as chestsSelect change
            handleSelectionChange();
        });
    });
});

</script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const gameData = {{ games_json|safe }}; // Game data as JSON
        const chestsSelect = document.getElementById("id_chests");
        const gameValuesField = document.getElementById("id_game_values");
        const totalValueField = document.getElementById("id_total_value");
        const quantitiesContainer = document.createElement("div"); // Container for quantity inputs
        quantitiesContainer.id = "quantities-container";
        chestsSelect.parentNode.appendChild(quantitiesContainer);

        // Function to update quantities and total value
        function updateGameValues() {
            let selectedGames = Array.from(chestsSelect.selectedOptions).map(option => parseInt(option.value));
            let gameValues = [];
            let totalValue = 0;

            selectedGames.forEach(gameId => {
                let game = gameData.find(g => g.id === gameId);
                if (game) {
                    let quantityInput = document.getElementById(`quantity-${gameId}`);
                    let quantity = quantityInput ? parseInt(quantityInput.value) || 1 : 1;
                    let gameCost = game.cost || 0;
                    let totalGameCost = quantity * gameCost;
                    gameValues.push(`${game.name}: ${quantity} x ${gameCost} = ${totalGameCost}`);
                    totalValue += totalGameCost;
                }
            });

            gameValuesField.value = gameValues.join("\n");
            totalValueField.value = totalValue;
        }

        // Function to add a quantity input
        function addQuantityInput(gameId, gameName) {
            let quantityDiv = document.createElement("div");
            quantityDiv.id = `quantity-container-${gameId}`;
            quantityDiv.innerHTML = `
                <label for="quantity-${gameId}">${gameName} Quantity:</label>
                <input type="number" id="quantity-${gameId}" name="quantity-${gameId}" value="1" min="1" class="form-control">
            `;
            quantitiesContainer.appendChild(quantityDiv);

            // Listen for changes to update game values
            document.getElementById(`quantity-${gameId}`).addEventListener("input", updateGameValues);
        }

        // Function to remove a quantity input
        function removeQuantityInput(gameId) {
            let quantityDiv = document.getElementById(`quantity-container-${gameId}`);
            if (quantityDiv) {
                quantityDiv.remove();
            }
        }

        // Handle changes to the chests field
        chestsSelect.addEventListener("change", function () {
            let selectedGameIds = Array.from(chestsSelect.selectedOptions).map(option => parseInt(option.value));
            let allGameIds = gameData.map(game => game.id);

            allGameIds.forEach(gameId => {
                let game = gameData.find(g => g.id === gameId);
                if (selectedGameIds.includes(gameId)) {
                    if (!document.getElementById(`quantity-container-${gameId}`)) {
                        addQuantityInput(gameId, game.name);
                    }
                } else {
                    removeQuantityInput(gameId);
                }
            });

            updateGameValues();
        });
    });
</script>

    <div class="casino-background"></div>
    <div class="container">
        <header>
            <h1>Luxury Casino Battle Creator</h1>
        </header>
        <main>

<form method="post"id="battle-creator-form">
    {% csrf_token %}

    <!-- Render the 'battle_name' field -->
    <div class="form-group">
        <label for="{{ form.battle_name.id_for_label }}">{{ form.battle_name.label }}</label>
        {{ form.battle_name }}
        {% if form.battle_name.help_text %}
            <small class="form-text text-muted">{{ form.battle_name.help_text }}</small>
        {% endif %}
        {% for error in form.battle_name.errors %}
            <span class="text-danger">{{ error }}</span>
        {% endfor %}
    </div>

    <!-- Render the 'chests' field -->
    <div class="form-group">
        <label for="{{ form.chests.id_for_label }}">{{ form.chests.label }}</label>
        <div class="chest-widget">
    <button id="toggle-chests" class="btn btn-primary">Select Chests</button>
    <div id="chests-container" class="chest-content" style="display: none;">
        <div class="chestlabel">
            {{ form.chests }}
        </div>
    </div>
</div>
         {% for game in form.chests.field.queryset %}
        <div class="form-check">
            <input
                type="checkbox"
                name="chests"
                id="game_{{ game.id }}"
                value="{{ game.id }}"
                class="form-check-input"
                {% if game in form.chests.value %}checked{% endif %}
            >
            <label class="form-check-label" for="game_{{ game.id }}">
                <img
                    src="{{ game.image.url }}"
                    alt="{{ game.name }}"
                    style="width: 50px; height: 50px; object-fit: cover; margin-right: 10px;"
                >
                {{ game.name }}
            </label>
        </div>
    {% endfor %}
        {% if form.chests.help_text %}
            <small class="form-text text-muted">{{ form.chests.help_text }}</small>
        {% endif %}
        {% for error in form.chests.errors %}
            <span class="text-danger">{{ error }}</span>
        {% endfor %}
    </div>

    <!-- Render the 'min_human_participants' field -->
    <div class="form-group">
        <label for="{{ form.min_human_participants.id_for_label }}">{{ form.min_human_participants.label }}</label>
        {{ form.min_human_participants }}
        {% if form.min_human_participants.help_text %}
            <small class="form-text text-muted">{{ form.min_human_participants.help_text }}</small>
        {% endif %}
        {% for error in form.min_human_participants.errors %}
            <span class="text-danger">{{ error }}</span>
        {% endfor %}
    </div>



<!-- Render the 'slots' field as radio buttons -->
<div class="form-group">
    <label>{{ form.slots.label }}</label>
                    <div class="radio-group">
    {% for choice in form.slots %}
        <div class="form-check">
            {{ choice.tag }}  <!-- Renders the radio button -->
            <label class="form-check-label" for="{{ choice.id_for_label }}">
                {{ choice.choice_label }}  <!-- Renders the label for the radio button -->
            </label>
        </div>
    {% endfor %}
    {% for error in form.slots.errors %}
        <span class="text-danger">{{ error }}</span>
    {% endfor %}
</div>
</div>

    <!-- Render the 'game_values' field -->
    <div class="form-group">
        <label for="{{ form.game_values.id_for_label }}">{{ form.game_values.label }}</label>
        {{ form.game_values }}
        {% if form.game_values.help_text %}
            <small class="form-text text-muted">{{ form.game_values.help_text }}</small>
        {% endif %}
        {% for error in form.game_values.errors %}
            <span class="text-danger">{{ error }}</span>
        {% endfor %}
    </div>

    <!-- Render the 'total_value' field -->
    <div class="form-group">
        <label for="{{ form.total_value.id_for_label }}">{{ form.total_value.label }}</label>
        {{ form.total_value }}
        {% if form.total_value.help_text %}
            <small class="form-text text-muted">{{ form.total_value.help_text }}</small>
        {% endif %}
        {% for error in form.total_value.errors %}
            <span class="text-danger">{{ error }}</span>
        {% endfor %}
    </div>

    <!-- Submit Button -->
    <button type="submit"  class="submit-btn">Submit</button>
</form>

        </main></div>


</body>
</html>



def gamespin_spinner_choice_render_list(request):
    spinner_choice_renders = SpinnerChoiceRenders.objects.filter(game=self.game)
    return render(request, 'gamespin.html', {'spinner_choice_renders': spinner_choice_renders})


class PokeChestBackgroundView(BaseView):
    model = UserProfile
    template_name = "pokechests.html"

    def post(self, request, *args, **kwargs):
        form = WagerForm(request.POST, user_profile=request.user.user_profile)
        if form.is_valid():
            wager = form.save(commit=False)
            wager.user_profile = request.user.user_profile
            wager.save()
            return redirect('showcase:blackjack')  # replace with your actual view name
        else:
            # If the form is not valid, re-render the page with the form errors
            return self.get(request, *args, **kwargs)

    @csrf_exempt  # Handle CSRF if needed
    def update_wager(request):
        if request.method == 'POST':
            wager_id = request.POST.get('wager_id')
            outcome = request.POST.get('outcome')
            try:
                wager = Wager.objects.get(id=wager_id)
                wager.resolve(outcome)
                return JsonResponse({'status': 'success'})
            except Wager.DoesNotExist:
                return JsonResponse({'error': 'Wager not found.'}, status=404)
            except Exception as e:
                return JsonResponse({'error': str(e)}, status=500)
        else:
            return JsonResponse({'error': 'Invalid request method.'}, status=405)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # context['ShowcaseBackgroundImage'] = ShowcaseBackgroundImage.objects.all()
        context['BaseCopyrightTextFielded'] = BaseCopyrightTextField.objects.filter(is_active=1)
        context['Background'] = BackgroundImageBase.objects.filter(page=self.template_name).order_by("position")
        context['Titles'] = Titled.objects.filter(is_active=1).order_by("page")
        context['SentProfile'] = UserProfile.objects.get(user=self.request.user)
        context['Money'] = Currency.objects.filter(is_active=1).first()
        context['games'] = Game.objects.filter(is_active=1)  # Queryset of active games
        context['wager_form'] = WagerForm()

        newprofile = UpdateProfile.objects.filter(is_active=1)
        # Retrieve the author's profile avatar

        context['Profiles'] = newprofile

        for newprofile in context['Profiles']:
            user = newprofile.user
            profile = ProfileDetails.objects.filter(user=user).first()
            if profile:
                newprofile.newprofile_profile_picture_url = profile.avatar.url
                newprofile.newprofile_profile_url = newprofile.get_profile_url()

        return context


def gamespin_find_choice(request):
    # Generate a random nonce between 0 and 1000000
    generated_nonce = random.randint(0, 1000000)

    # Query the Choice model to find the choice that includes the generated nonce
    choice = Choice.objects.filter(lower_nonce__lte=generated_nonce, upper_nonce__gte=generated_nonce).first()

    # Pass the generated nonce and the found choice to the template
    context = {
        'generated_nonce': generated_nonce,
        'choice': choice
    }

    return render(request, 'gamespin.html', context)


class FindChoiceView(View):
    template_name = 'gamespin.html'

    def get(self, request, *args, **kwargs):
        # Generate a random nonce between 0 and 1000000
        generated_nonce = random.randint(0, 1000000)

        # Query the Choice model to find the choice that includes the generated nonce
        choice = Choice.objects.filter(lower_nonce__lte=generated_nonce, upper_nonce__gte=generated_nonce).first()

        # Pass the generated nonce and the found choice to the template
        context = {
            'generated_nonce': generated_nonce,
            'choice': choice
        }

        return render(request, self.template_name, context)


def gamespin_game_view(request, game_id):
    game = get_object_or_404(Game, id=game_id)

    # Use the discount cost if available, otherwise use the regular cost
    if game.daily:
        cost = 0
    else:
        cost = game.discount_cost if game.discount_cost else game.cost

    context = {
        'game': game,
        'cost_threshold_80': cost * 0.8,
        'cost_threshold_100': cost,
        'cost_threshold_200': cost * 2,
        'cost_threshold_500': cost * 5,
        'cost_threshold_10000': cost * 100,
    }

    return render(request, 'gamespin.html', context)
def gamespin_game_view(request, slug):
    game = get_object_or_404(Game, slug=slug)
    context = {
        'game': game,
        'games': Game.objects.all(),
        'cost_threshold_80': game.cost * 0.8,
        'cost_threshold_100': game.cost,
        'cost_threshold_200': game.cost * 2,
        'cost_threshold_500': game.cost * 5,
        'cost_threshold_10000': game.cost * 100,
    }

    if request.method == 'POST':
        # Generate between 500 and 1000 nonces dynamically
        num_nonces = random.randint(500, 1000)
        nonces = [random.randint(0, 1000000) for _ in range(num_nonces)]

        # Find the choices that match the nonces
        matching_choices = []
        for nonce in nonces:
            choices = Choice.objects.filter(lower_nonce__lte=nonce, upper_nonce__gte=nonce, game=game)
            for choice in choices:
                matching_choices.append((nonce, choice))

        # Randomize the order of choices
        random.shuffle(matching_choices)

        # Prepare data to return as JSON
        choices_data = [{
            'nonce': nonce,
            'choice_text': choice.choice_text,
            'value': choice.value,
            'file_url': choice.file.url
        } for nonce, choice in matching_choices]

        return JsonResponse({
            'status': 'success',
            'choices': choices_data
        })

    # Initial nonce generation for the template
    nonce = random.randint(1, 1000000)
    return render(request, 'gamespin.html', {'game': game, 'nonce': nonce})



# how the choices are rendered in gamespin.html
def gamespin_game_detail(request, game_id):
    game = Game.objects.get(id=game_id)
    choice_nonce_list = []

    for choice in game.choices.all():
        nonce = random.randint(0, 1000000)
        choice_nonce_list.append((choice, nonce))
        print(f"Choice: {choice.choice_text}, Nonce: {nonce}, Range: {choice.lower_nonce} - {choice.upper_nonce}")
        logger.info(f"Choice: {choice.choice_text}, Nonce: {nonce}, Range: {choice.lower_nonce} - {choice.upper_nonce}")

    return render(request, 'game_detail.html', {
        'game': game,
        'choice_nonce_list': choice_nonce_list,
    })



def gamespin_display_choices(request, game_id, slug):
    game = get_object_or_404(Game, id=game_id, slug=slug)
    choices = Choice.objects.filter(game=game)

    # Ensure each choice has a nonce
    for choice in choices:
        if choice.lower_nonce is None or choice.upper_nonce is None:
            choice.lower_nonce = random.randint(0, 1000000)
            choice.upper_nonce = random.randint(0, 1000000)
            choice.save()

    return render(request, 'gamespin.html', {'game': game, 'choices': choices})


class GameSpinChestBackgroundView(BaseView):
    template_name = "gamespin.html"

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        slug = self.kwargs.get('slug')
        context['slug'] = slug

        # Fetch data related to the user and game
        game = get_object_or_404(Game, slug=slug)
        context['game'] = game

        user = self.request.user
        if user.is_authenticated:
            try:
                context['SentProfile'] = UserProfile.objects.get(user=self.request.user)
            except UserProfile.DoesNotExist:
                context['SentProfile'] = None
        else:
            context['SentProfile'] = None

        context['Money'] = Currency.objects.filter(is_active=1).first()
        context['wager_form'] = WagerForm()

        choices = Choice.objects.filter(game=game)
        spinner_choice_renders = SpinnerChoiceRenders.objects.filter(game=game)
        context['spinner_choice_renders'] = spinner_choice_renders

        # Retrieve 'button_type' from the request
        button_type = self.request.GET.get('button_type') or self.request.POST.get('button_type')

        # Determine cost based on button type
        if button_type == "start2":  # If Demo Spin is pressed
            cost = 0
        else:  # If normal Spin is pressed
            cost = game.discount_cost if game.discount_cost else game.cost

        context.update({
            'cost_threshold_80': cost * 0.8,
            'cost_threshold_100': cost,
            'cost_threshold_200': cost * 2,
            'cost_threshold_500': cost * 5,
            'cost_threshold_10000': cost * 100,
        })

        newprofile = UpdateProfile.objects.filter(is_active=1)
        context['Profiles'] = newprofile

        for newprofile in context['Profiles']:
            user = newprofile.user
            profile = ProfileDetails.objects.filter(user=user).first()
            if profile:
                newprofile.newprofile_profile_picture_url = profile.avatar.url
                newprofile.newprofile_profile_url = newprofile.get_profile_url()

        user_profile = None  # Initialize to ensure it always exists
        if game.user:
            # Perform actions only if the `user` field is filled
            user_profile, created = UserProfile.objects.get_or_create(user=game.user)
            # Additional logic if necessary

        context['SentProfile'] = user_profile
        if game.user:
            user_cash = user_profile.currency_amount

            context = {
                'user_cash': user_cash,
            }

        context['Money'] = Currency.objects.filter(is_active=1).first()

        spinpreference = None  # Initialize spinpreference to ensure it exists

        if user.is_authenticated:
            try:
                spinpreference = SpinPreference.objects.get(user=user)
            except SpinPreference.DoesNotExist:
                spinpreference = SpinPreference(user=user, quick_spin=False)
                spinpreference.save()

            context['quick_spin'] = spinpreference.quick_spin
        else:
            context['quick_spin'] = False

        context['spinpreference'] = spinpreference

        if self.request.user.is_authenticated:
            userprofile = ProfileDetails.objects.filter(is_active=1, user=self.request.user)
        else:
            userprofile = None

        if userprofile:
            context['Profiles'] = userprofile
        else:
            context['Profiles'] = None

        if context['Profiles'] == None:
            # Create a new object with the necessary attributes
            userprofile = type('', (), {})()
            userprofile.newprofile_profile_picture_url = 'static/css/images/a.jpg'
            userprofile.newprofile_profile_url = None
        else:
            for userprofile in context['Profiles']:
                user = userprofile.user
                profile = ProfileDetails.objects.filter(user=user).first()
                if profile:
                    userprofile.newprofile_profile_picture_url = profile.avatar.url
                    userprofile.newprofile_profile_url = userprofile.get_profile_url()

        # Initialize the form with spinpreference instance, or None if not authenticated
        if spinpreference:
            spinform = SpinPreferenceForm(instance=spinpreference)
        else:
            spinform = SpinPreferenceForm()  # Initialize an empty form if spinpreference is None
        context['spin_preference_form'] = spinform

        if user.is_authenticated:
            # Determine the random amount based on quick_spin preference
            if spinpreference.quick_spin:
                random_amount = random.randint(500, 1000)
            else:
                random_amount = random.randint(150, 300)
        else:
            random_amount = random.randint(150, 300)

        context['random_amount'] = random_amount
        context['range_random_amount'] = range(random_amount)
        print(str('the random amount is ') + str(random_amount))

        # Generate a list of random nonces
        random_nonces = [random.randint(0, 1000000) for _ in range(random_amount)]
        context['random_nonces'] = random_nonces

        # Create a list to store choices matched with the generated nonces
        choices_with_nonce = []
        for nonce in random_nonces:
            for choice in choices:
                if choice.lower_nonce <= nonce <= choice.upper_nonce:
                    choices_with_nonce.append({
                        'choice': choice,
                        'nonce': nonce,
                        'lower_nonce': choice.lower_nonce,
                        'upper_nonce': choice.upper_nonce,
                        'file_url': choice.file.url if choice.file else None,  # Get the URL of the file field
                        'currency': {
                            'symbol': choice.currency.name if choice.currency else '💎',
                            'file_url': choice.currency.file.url if choice.currency and choice.currency.file else None
                        }
                    })
                    break  # Exit after finding the first match for this nonce

        context['choices_with_nonce'] = choices_with_nonce

        # Get the game_id from the URL kwargs
        game_id = self.kwargs.get('slug')

        # Retrieve the Game object
        game = get_object_or_404(Game, slug=slug)

        # Retrieve related Choice objects
        choices = Choice.objects.filter(game=game)

        # Add them to the context
        context['game'] = game
        context['choices'] = choices

        context['Background'] = BackgroundImageBase.objects.filter(page=self.template_name).order_by("position")
        print(context['Background'])

        context['BaseCopyrightTextFielded'] = BaseCopyrightTextField.objects.filter(is_active=1)
        context['Titles'] = Titled.objects.filter(is_active=1).order_by("page")
        context['Header'] = NavBarHeader.objects.filter(is_active=1).order_by("row")
        context['DropDown'] = NavBar.objects.filter(is_active=1).order_by('position')
        context['Logo'] = LogoBase.objects.filter(page=self.template_name, is_active=1)
        return context


    @method_decorator(login_required)
    def post(self, request, *args, **kwargs):
        action = self.request.POST.get('action')
        pk = self.request.POST.get('pk')

        def post(self, request, *args, **kwargs):
            action = self.request.POST.get('action')
            if action == 'sell':
                return self.sell_game_inventory_object(request)
    def sell_game_inventory_object(self, request):
        # Get the most recently created InventoryObject for the current user
        inventory_object = InventoryObject.objects.filter(
            user=request.user,
            inventory__isnull=False,  # Ensure it's still in inventory
        ).order_by('-created_at').first()  # Get the latest instance

        if not inventory_object:
            messages.error(request, 'No items available to sell!')
            return redirect('showcase:inventory')

        # Update InventoryObject
        inventory_object.user = None
        inventory_object.inventory = None

        with transaction.atomic():
            # Create the Transaction instance
            Transaction.objects.create(
                inventory_object=inventory_object,
                user=request.user,
                currency=inventory_object.currency,
                amount=inventory_object.price
            )

            # Save the updated InventoryObject
            inventory_object.save()

            # Update UserProfile's currency_amount
            user_profile = get_object_or_404(UserProfile, user=request.user)
            user_profile.currency_amount += inventory_object.price
            user_profile.save()

        messages.success(request,
                         f"Successfully sold {inventory_object.choice} for {inventory_object.price} {inventory_object.currency}!")
        return redirect('showcase:inventory')

    def game_detail(request, slug):
        game = get_object_or_404(Game, slug=slug)
        choices = game.choices.all()  # Get all related choices for the game
        return render(request, 'game_detail.html', {'game': game, 'choices': choices})

    def display_choices(request, game_id, slug):
        game = get_object_or_404(Game, id=game_id, slug=slug)
        choices = Choice.objects.filter(game=game)

        # Ensure each choice has a nonce
        for choice in choices:
            if choice.lower_nonce is None or choice.upper_nonce is None:
                choice.lower_nonce = random.randint(0, 1000000)
                choice.upper_nonce = random.randint(0, 1000000)
                choice.save()

        return render(request, 'gamespin.html', {'game': game, 'choices': choices})

    # Example usage in a view or any other part of your application
    def take_spinner_slot(user, game, choice):
        SpinnerChoiceRenders.take_up_slot(user=user, game=game, choice=choice, value=100, ratio=2, type=game.type,
                                          image=choice.image.url, color=choice.color)

    def save_spin_preference(request):
        if request.method == "POST" and request.is_ajax():
            quick_spin = request.POST.get('quick_spin') == 'true'
            spinpreference, created = SpinPreference.objects.get_or_create(user=request.user)
            spinpreference.quick_spin = quick_spin
            spinpreference.save()
            return JsonResponse({'success': True})
        return JsonResponse({'success': False}, status=400)

    def wager(self, request, *args, **kwargs):
        form = WagerForm(request.POST, user_profile=request.user.user_profile)
        if form.is_valid():
            wager = form.save(commit=False)
            wager.user_profile = request.user.user_profile
            wager.save()
            return redirect('showcase:blackjack')  # replace with your actual view name
        else:
            # If the form is not valid, re-render the page with the form errors
            return self.get(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        if request.method == "POST" and request.headers.get('x-requested-with') == 'XMLHttpRequest':
            quick_spin = request.POST.get('quick_spin') == 'true'
            spinpreference, created = SpinPreference.objects.get_or_create(user=request.user)
            spinpreference.quick_spin = quick_spin
            spinpreference.save()
            return JsonResponse({'success': True})
        return JsonResponse({'success': False}, status=400)

    @csrf_exempt
    def create_outcome(request, slug):
        if request.method == 'POST':
            try:
                game_id = request.POST.get('game_id')
                user = request.user

                if not game_id:
                    return JsonResponse({'status': 'error', 'message': 'Game ID is required.'})

                game = Game.objects.get(id=game_id, slug=slug)
                nonce = random.randint(1, 1000000)
                choices = Choice.objects.filter(lower_nonce__lte=nonce, upper_nonce__gte=nonce)

                if not choices.exists():
                    return JsonResponse({'status': 'error', 'message': 'No valid choice found for the given nonce.'})

                choice = choices.order_by('?').first()

                color = game.get_color(choice)
                choice.color = color
                choice.save()  # Save the updated color to the database

                # Print the selected choice fields to the console
                print(f"Selected Choice ID: {choice.id}")
                print(f"Selected Choice Text: {choice.choice_text}")
                print(f"Selected Choice Color: {choice.color}")
                print(f"Selected Choice File: {choice.file.url if choice.file else 'No file associated'}")

                outcome_data = {
                    'game': game,
                    'choice': choice,
                    'nonce': nonce,
                    'value': random.randint(1, 1000000),
                    'ratio': random.randint(1, 10),
                    'type': game.type
                }

                if user.is_authenticated:
                    outcome_data['user'] = user

                outcome = Outcome.objects.create(**outcome_data)

                return JsonResponse({
                    'status': 'success',
                    'outcome': outcome.id,
                    'nonce': outcome.nonce,
                    'choice_id': choice.id,
                    'choice_text': choice.choice_text,
                    'choice_color': choice.color,
                    'choice_file': choice.file.url if choice.file else None
                })

            except Game.DoesNotExist:
                return JsonResponse({'status': 'error', 'message': 'Game not found.'})
            except Exception as e:
                return JsonResponse({'status': 'error', 'message': str(e)})

        return JsonResponse({'status': 'error', 'message': 'Invalid request method.'})

    def create_spinner_choice_render_automatically(request):
        nonce = random.randint(0, 1000000)
        choice = Choice.objects.filter(Q(lower_nonce__lte=nonce) & Q(upper_nonce__gte=nonce)).first()

        if choice:
            game = choice.game
            game_hub = GameHub.objects.first()

            spinner_choice_render = SpinnerChoiceRenders.objects.create(
                user=choice.user,
                value=choice.value,
                ratio=choice.rarity,
                type=game_hub,
                image=choice.file,
                color=choice.color,
                game=game,
                choice=choice,
                nonce=nonce,
                is_active=1,
            )
            return redirect('showcase:game', slug=choice.slug)
        else:
            return render(request, 'error.html', {'message': 'No choice found for the generated nonce'})

    def spinner_choice_render_list(request):
        spinner_choice_renders = SpinnerChoiceRenders.objects.filter(game=self.game)
        return render(request, 'gamespin.html', {'spinner_choice_renders': spinner_choice_renders})

    @csrf_exempt
    def layoutspinner(request, slug):
        if request.method == 'POST':
            game_id = request.POST.get('game_id')
            user = request.user

            if not game_id:
                return JsonResponse({'status': 'error', 'message': 'Game ID is required.'})

            try:
                game = Game.objects.get(id=game_id, slug=slug)
                nonce = random.randint(1, 1000000)
                choices = Choice.objects.filter(lower_nonce__lte=nonce, upper_nonce__gte=nonce)

                if not choices.exists():
                    return JsonResponse({'status': 'error', 'message': 'No valid choice found for the given nonce.'})

                choice = choices.order_by('?').first()

                outcome = Outcome.objects.create(
                    user=user,
                    game=game,
                    choice=choice,
                    nonce=nonce,
                    value=random.randint(1, 1000000),
                    ratio=random.randint(1, 10),
                    type=game.type
                )
                return JsonResponse({'status': 'success', 'outcome': outcome.id, 'nonce': outcome.nonce})
            except Game.DoesNotExist:
                return JsonResponse({'status': 'error', 'message': 'Game not found.'})
            except Exception as e:
                return JsonResponse({'status': 'error', 'message': str(e)})

        return JsonResponse({'status': 'error', 'message': 'Invalid request method.'})

    @csrf_exempt
    def update_wager(self, request):
        if request.method == 'POST':
            wager_id = request.POST.get('wager_id')
            outcome = request.POST.get('outcome')
            try:
                wager = Wager.objects.get(id=wager_id)
                wager.resolve(outcome)
                return JsonResponse({'status': 'success'})
            except Wager.DoesNotExist:
                return JsonResponse({'error': 'Wager not found.'}, status=404)
            except Exception as e:
                return JsonResponse({'error': str(e)}, status=500)
        else:
            return JsonResponse({'error': 'Invalid request method.'}, status=405)


class DailySpinChestView(BaseView):
    template_name = "gamespin.html"

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        slug = self.kwargs.get('slug')
        context['slug'] = slug

        # Fetch data related to the user and game

        game = get_object_or_404(Game, slug=slug)

        # Pass the game as a list
        context['game'] = game

        user = self.request.user
        if user.is_authenticated:
            try:
                context['SentProfile'] = UserProfile.objects.get(user=self.request.user)
            except UserProfile.DoesNotExist:
                context['SentProfile'] = None
        else:
            context['SentProfile'] = None

        context['Money'] = Currency.objects.filter(is_active=1).first()
        context['wager_form'] = WagerForm()

        game = get_object_or_404(Game, slug=slug)
        context['games'] = game
        choices = Choice.objects.filter(game=game)
        spinner_choice_renders = SpinnerChoiceRenders.objects.filter(game=game)
        context['spinner_choice_renders'] = spinner_choice_renders
        if game.daily:
            cost = 0
        else:
            cost = game.discount_cost if game.discount_cost else game.cost
        context.update({
            'cost_threshold_80': cost * 0.8,
            'cost_threshold_100': cost,
            'cost_threshold_200': cost * 2,
            'cost_threshold_500': cost * 5,
            'cost_threshold_10000': cost * 100,
        })

        newprofile = UpdateProfile.objects.filter(is_active=1)
        context['Profiles'] = newprofile

        for newprofile in context['Profiles']:
            user = newprofile.user
            profile = ProfileDetails.objects.filter(user=user).first()
            if profile:
                newprofile.newprofile_profile_picture_url = profile.avatar.url
                newprofile.newprofile_profile_url = newprofile.get_profile_url()

        user_profile = None  # Initialize to ensure it always exists
        if game.user:
            # Perform actions only if the `user` field is filled
            user_profile, created = UserProfile.objects.get_or_create(user=game.user)
            # Additional logic if necessary

        context['SentProfile'] = user_profile
        if game.user:
            user_cash = user_profile.currency_amount

            context = {
                'user_cash': user_cash,
            }

        context['Money'] = Currency.objects.filter(is_active=1).first()

        spinpreference = None  # Initialize spinpreference to ensure it exists

        if user.is_authenticated:
            try:
                spinpreference = SpinPreference.objects.get(user=user)
            except SpinPreference.DoesNotExist:
                spinpreference = SpinPreference(user=user, quick_spin=False)
                spinpreference.save()

            context['quick_spin'] = spinpreference.quick_spin
        else:
            context['quick_spin'] = False

        context['spinpreference'] = spinpreference

        if self.request.user.is_authenticated:
            userprofile = ProfileDetails.objects.filter(is_active=1, user=self.request.user)
        else:
            userprofile = None

        if userprofile:
            context['Profiles'] = userprofile
        else:
            context['Profiles'] = None

        if context['Profiles'] == None:
            # Create a new object with the necessary attributes
            userprofile = type('', (), {})()
            userprofile.newprofile_profile_picture_url = 'static/css/images/a.jpg'
            userprofile.newprofile_profile_url = None
        else:
            for userprofile in context['Profiles']:
                user = userprofile.user
                profile = ProfileDetails.objects.filter(user=user).first()
                if profile:
                    userprofile.newprofile_profile_picture_url = profile.avatar.url
                    userprofile.newprofile_profile_url = userprofile.get_profile_url()

        # Initialize the form with spinpreference instance, or None if not authenticated
        if spinpreference:
            spinform = SpinPreferenceForm(instance=spinpreference)
        else:
            spinform = SpinPreferenceForm()  # Initialize an empty form if spinpreference is None
        context['spin_preference_form'] = spinform

        if user.is_authenticated:
            # Determine the random amount based on quick_spin preference
            if spinpreference.quick_spin:
                random_amount = random.randint(500, 1000)
            else:
                random_amount = random.randint(150, 300)
        else:
            random_amount = random.randint(150, 300)

        context['random_amount'] = random_amount
        context['range_random_amount'] = range(random_amount)
        print(str('the random amount is ') + str(random_amount))

        # Generate a list of random nonces
        random_nonces = [random.randint(0, 1000000) for _ in range(random_amount)]
        context['random_nonces'] = random_nonces

        # Create a list to store choices matched with the generated nonces
        choices_with_nonce = []
        for nonce in random_nonces:
            for choice in choices:
                if choice.lower_nonce <= nonce <= choice.upper_nonce:
                    choices_with_nonce.append({
                        'choice': choice,
                        'nonce': nonce,
                        'lower_nonce': choice.lower_nonce,
                        'upper_nonce': choice.upper_nonce,
                        'file_url': choice.file.url if choice.file else None,  # Get the URL of the file field
                        'currency': {
                            'symbol': choice.currency.name if choice.currency else '💎',
                            'file_url': choice.currency.file.url if choice.currency and choice.currency.file else None
                        }
                    })
                    break  # Exit after finding the first match for this nonce

        context['choices_with_nonce'] = choices_with_nonce

        # Get the game_id from the URL kwargs
        game_id = self.kwargs.get('slug')

        # Retrieve the Game object
        game = get_object_or_404(Game, slug=slug)

        # Retrieve related Choice objects
        choices = Choice.objects.filter(game=game)

        # Add them to the context
        context['game'] = game
        context['choices'] = choices

        context['Background'] = BackgroundImageBase.objects.filter(page=self.template_name).order_by("position")
        print(context['Background'])

        context['BaseCopyrightTextFielded'] = BaseCopyrightTextField.objects.filter(is_active=1)
        context['Titles'] = Titled.objects.filter(is_active=1).order_by("page")
        context['Header'] = NavBarHeader.objects.filter(is_active=1).order_by("row")
        context['DropDown'] = NavBar.objects.filter(is_active=1).order_by('position')
        context['Logo'] = LogoBase.objects.filter(page=self.template_name, is_active=1)
        return context

    def game_detail(request, slug):
        game = get_object_or_404(Game, slug=slug)
        choices = game.choices.all()  # Get all related choices for the game
        return render(request, 'game_detail.html', {'game': game, 'choices': choices})

    def display_choices(request, game_id, slug):
        game = get_object_or_404(Game, id=game_id, slug=slug)
        choices = Choice.objects.filter(game=game)

        # Ensure each choice has a nonce
        for choice in choices:
            if choice.lower_nonce is None or choice.upper_nonce is None:
                choice.lower_nonce = random.randint(0, 1000000)
                choice.upper_nonce = random.randint(0, 1000000)
                choice.save()

        return render(request, 'gamespin.html', {'game': game, 'choices': choices})

    # Example usage in a view or any other part of your application
    def take_spinner_slot(user, game, choice):
        SpinnerChoiceRenders.take_up_slot(user=user, game=game, choice=choice, value=100, ratio=2,
                                          type=game.type,
                                          image=choice.image.url, color=choice.color)

    def save_spin_preference(request):
        if request.method == "POST" and request.is_ajax():
            quick_spin = request.POST.get('quick_spin') == 'true'
            spinpreference, created = SpinPreference.objects.get_or_create(user=request.user)
            spinpreference.quick_spin = quick_spin
            spinpreference.save()
            return JsonResponse({'success': True})
        return JsonResponse({'success': False}, status=400)

    def wager(self, request, *args, **kwargs):
        form = WagerForm(request.POST, user_profile=request.user.user_profile)
        if form.is_valid():
            wager = form.save(commit=False)
            wager.user_profile = request.user.user_profile
            wager.save()
            return redirect('showcase:blackjack')  # replace with your actual view name
        else:
            # If the form is not valid, re-render the page with the form errors
            return self.get(request, *args, **kwargs)

    def post(self, request, *args, **kwargs):
        if request.method == "POST" and request.headers.get('x-requested-with') == 'XMLHttpRequest':
            quick_spin = request.POST.get('quick_spin') == 'true'
            spinpreference, created = SpinPreference.objects.get_or_create(user=request.user)
            spinpreference.quick_spin = quick_spin
            spinpreference.save()
            return JsonResponse({'success': True})
        return JsonResponse({'success': False}, status=400)

    @csrf_exempt
    def create_outcome(request, slug):
        if request.method == 'POST':
            try:
                game_id = request.POST.get('game_id')
                user = request.user

                if not game_id:
                    return JsonResponse({'status': 'error', 'message': 'Game ID is required.'})

                game = Game.objects.get(id=game_id, slug=slug)
                nonce = random.randint(1, 1000000)
                choices = Choice.objects.filter(lower_nonce__lte=nonce, upper_nonce__gte=nonce)

                if not choices.exists():
                    return JsonResponse(
                        {'status': 'error', 'message': 'No valid choice found for the given nonce.'})

                choice = choices.order_by('?').first()

                color = game.get_color(choice)
                choice.color = color
                choice.save()  # Save the updated color to the database

                # Print the selected choice fields to the console
                print(f"Selected Choice ID: {choice.id}")
                print(f"Selected Choice Text: {choice.choice_text}")
                print(f"Selected Choice Color: {choice.color}")
                print(f"Selected Choice File: {choice.file.url if choice.file else 'No file associated'}")

                outcome_data = {
                    'game': game,
                    'choice': choice,
                    'nonce': nonce,
                    'value': random.randint(1, 1000000),
                    'ratio': random.randint(1, 10),
                    'type': game.type
                }

                if user.is_authenticated:
                    outcome_data['user'] = user

                outcome = Outcome.objects.create(**outcome_data)

                return JsonResponse({
                    'status': 'success',
                    'outcome': outcome.id,
                    'nonce': outcome.nonce,
                    'choice_id': choice.id,
                    'choice_text': choice.choice_text,
                    'choice_color': choice.color,
                    'choice_file': choice.file.url if choice.file else None
                })

            except Game.DoesNotExist:
                return JsonResponse({'status': 'error', 'message': 'Game not found.'})
            except Exception as e:
                return JsonResponse({'status': 'error', 'message': str(e)})

        return JsonResponse({'status': 'error', 'message': 'Invalid request method.'})



def gamespin_detail(request, game_id):
    game = get_object_or_404(Game, id=game_id)
    choices = Choice.objects.filter(game=game)

    context = {
        'game': game,
        'choices': choices,
    }

    return render(request, 'gamespin.html', context)
